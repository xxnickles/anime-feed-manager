using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AnimeFeedManager.SourceGenerators.TableNames;

[Generator]
public class TableNameMapGenerator : IIncrementalGenerator
{
    private const string AttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace AnimeFeedManager.SourceGenerators.TableNames;

        /// <summary>
        /// Specifies the Azure Table Storage table name for this entity.
        /// The entity must implement Azure.Data.Tables.ITableEntity.
        /// </summary>
        [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false)]
        [Microsoft.CodeAnalysis.Embedded]
        internal sealed class WithTableNameAttribute : System.Attribute
        {
            /// <summary>
            /// Initializes a new instance of the WithTableNameAttribute.
            /// </summary>
            /// <param name="tableName">The name of the Azure table</param>
            public WithTableNameAttribute(string tableName)
            {
                TableName = tableName;
            }

            /// <summary>
            /// Gets the table name.
            /// </summary>
            public string TableName { get; }
        }
        """;

    private static readonly DiagnosticDescriptor InvalidAttributeUsage = new(
        id: "TNM001",
        title: "Invalid attribute usage",
        messageFormat: "WithTableNameAttribute can only be applied to classes that implement ITableEntity",
        category: "TableNameMapGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the embedded attribute definition
        context.RegisterPostInitializationOutput(static postInitContext =>
        {
            postInitContext.AddEmbeddedAttributeDefinition();
            postInitContext.AddSource("WithTableNameAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Use ForAttributeWithMetadataName for 99x performance improvement
        var tableEntities = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "AnimeFeedManager.SourceGenerators.TableNames.WithTableNameAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetTableEntityInfo(ctx))
            .Where(static m => m.HasValue)
            .Select(static (m, _) => m!.Value);

        // Combine with the compilation for diagnostics
        var compilationAndEntities = context.CompilationProvider.Combine(tableEntities.Collect());

        // Generate the source code
        context.RegisterSourceOutput(compilationAndEntities,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static (string EntityTypeName, string EntityNamespace, string TableName, Location Location, bool ImplementsITableEntity)?
        GetTableEntityInfo(GeneratorAttributeSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

        // Skip static or abstract classes
        if (classSymbol.IsStatic || classSymbol.IsAbstract)
            return null;

        // Check if implements ITableEntity
        var tableEntitySymbol = context.SemanticModel.Compilation
            .GetTypeByMetadataName("Azure.Data.Tables.ITableEntity");

        var implementsITableEntity = tableEntitySymbol != null &&
                                      ImplementsInterface(classSymbol, tableEntitySymbol);

        // Get table name from attribute
        var attribute = context.Attributes.FirstOrDefault();
        if (attribute?.ConstructorArguments.Length > 0 &&
            attribute.ConstructorArguments[0].Value is string tableName)
        {
            return (
                classSymbol.Name,
                classSymbol.ContainingNamespace.ToDisplayString(),
                tableName,
                classDeclaration.GetLocation(),
                implementsITableEntity
            );
        }

        return null;
    }

    private static bool ImplementsInterface(INamedTypeSymbol classSymbol, INamedTypeSymbol interfaceType)
    {
        return classSymbol.AllInterfaces.Any(i =>
            SymbolEqualityComparer.Default.Equals(i, interfaceType));
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<(string EntityTypeName, string EntityNamespace, string TableName, Location Location, bool ImplementsITableEntity)> entities,
        SourceProductionContext context)
    {
        if (entities.IsDefaultOrEmpty)
            return;

        var validEntities = new List<(string EntityTypeName, string EntityNamespace, string TableName)>();

        foreach (var entity in entities)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            if (!entity.ImplementsITableEntity)
            {
                // Report diagnostic error
                context.ReportDiagnostic(Diagnostic.Create(InvalidAttributeUsage, entity.Location));
                continue;
            }

            validEntities.Add((entity.EntityTypeName, entity.EntityNamespace, entity.TableName));
        }

        if (validEntities.Count > 0)
        {
            var source = GenerateTableNameMapSource(validEntities);
            context.AddSource("TableNameMap.g.cs", source);
        }
    }

    private static string GenerateTableNameMapSource(
        List<(string EntityTypeName, string EntityNamespace, string TableName)> tableEntities)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");

        // Add all the namespaces needed for the entity types
        var namespaces = tableEntities.Select(te => te.EntityNamespace).Distinct().ToList();
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace AnimeFeedManager.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated map of entity types to their Azure table names.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class AzureTableName");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly Dictionary<Type, string> TypeToTableNameMap = new()");
        sb.AppendLine("    {");

        foreach (var (entityTypeName, entityNamespace, tableName) in tableEntities)
        {
            sb.AppendLine($"        [typeof({entityNamespace}.{entityTypeName})] = \"{tableName}\",");
        }

        sb.AppendLine("    };");
        sb.AppendLine();

        // Generate individual constants for each table name
        sb.AppendLine("    // Individual table name constants");
        var distinctTableNames = tableEntities.Select(te => te.TableName).Distinct().OrderBy(t => t).ToList();
        foreach (var tableName in distinctTableNames)
        {
            // Create a valid C# identifier from the table name
            var constantName = CreateValidIdentifier(tableName);
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Table name constant for '{tableName}'");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public const string {constantName} = \"{tableName}\";");
            sb.AppendLine();
        }

        // Generate array with all table names
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Array containing all discovered table names.");
        sb.AppendLine("    /// </summary>");
        sb.Append("    public static readonly string[] AllTableNames = {");

        if (distinctTableNames.Count > 0)
        {
            sb.AppendLine();
            for (int i = 0; i < distinctTableNames.Count; i++)
            {
                var constantName = CreateValidIdentifier(distinctTableNames[i]);
                sb.Append($"        {constantName}");
                if (i < distinctTableNames.Count - 1)
                    sb.Append(",");
                sb.AppendLine();
            }

            sb.AppendLine("    };");
        }
        else
        {
            sb.AppendLine(" };");
        }

        sb.AppendLine();

        // Generate ReadOnlySpan property for performance
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// ReadOnlySpan containing all discovered table names for efficient iteration.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static ReadOnlySpan<string> AllTableNamesSpan => AllTableNames;");

        sb.AppendLine();

        // Generate count property
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Total number of discovered tables.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public const int TableCount = {distinctTableNames.Count};");

        sb.AppendLine();

        // Keep the existing methods
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the table name for the specified entity type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"entityType\">The type of the entity</param>");
        sb.AppendLine("    /// <returns>The table name for the specified entity type</returns>");
        sb.AppendLine(
            "    /// <exception cref=\"KeyNotFoundException\">Thrown when the entity type is not registered in the table name map</exception>");
        sb.AppendLine("    public static string GetTableName(Type entityType)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (TypeToTableNameMap.TryGetValue(entityType, out var tableName))");
        sb.AppendLine("        {");
        sb.AppendLine("            return tableName;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine(
            "        throw new KeyNotFoundException($\"No table name found for entity type: {entityType.FullName}. Make sure the type has a WithTableNameAttribute.\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the table name for the specified entity type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <typeparam name=\"T\">The type of the entity</typeparam>");
        sb.AppendLine("    /// <returns>The table name for the specified entity type</returns>");
        sb.AppendLine(
            "    /// <exception cref=\"KeyNotFoundException\">Thrown when the entity type is not registered in the table name map</exception>");
        sb.AppendLine("    public static string GetTableName<T>()");
        sb.AppendLine("    {");
        sb.AppendLine("        return GetTableName(typeof(T));");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string CreateValidIdentifier(string tableName)
    {
        if (string.IsNullOrEmpty(tableName))
            return "Unknown";

        var sb = new StringBuilder();

        // First character must be a letter or underscore
        var firstChar = tableName[0];
        if (char.IsLetter(firstChar))
            sb.Append(char.ToUpper(firstChar));
        else
            sb.Append('_');

        // Process remaining characters
        for (int i = 1; i < tableName.Length; i++)
        {
            var c = tableName[i];
            if (char.IsLetterOrDigit(c))
            {
                sb.Append(c);
            }
            else if (c == '-' || c == '_' || c == '.')
            {
                sb.Append('_');
            }
            // Skip other invalid characters
        }

        var result = sb.ToString();

        // Ensure it's not a C# keyword
        if (IsCSharpKeyword(result))
            result = "@" + result;

        return result;
    }

    private static bool IsCSharpKeyword(string identifier)
    {
        var keywords = new HashSet<string>
        {
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
            "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
            "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
            "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
            "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
            "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
            "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this",
            "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
            "using", "virtual", "void", "volatile", "while"
        };

        return keywords.Contains(identifier.ToLower());
    }
}

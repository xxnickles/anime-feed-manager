using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace AnimeFeedManager.SourceGenerators.Validation;

/// <summary>
/// Generates extension methods for chaining Validation&lt;T&gt;.And() calls
/// with flat tuple accumulation up to 7 elements.
/// Only emits code when compiling AnimeFeedManager.Shared to access internal members.
/// </summary>
[Generator]
public class ValidationAndExtensionsGenerator : IIncrementalGenerator
{
    private const int MaxTupleSize = 7;
    private const string TargetAssemblyName = "AnimeFeedManager.Shared";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use compilation provider to check assembly name before emitting
        context.RegisterSourceOutput(
            context.CompilationProvider,
            static (spc, compilation) => EmitValidationExtensions(spc, compilation));
    }

    private static void EmitValidationExtensions(SourceProductionContext context, Compilation compilation)
    {
        // Only emit in the target assembly (AnimeFeedManager.Shared)
        // This allows the generated code to access internal members of Validation<T>
        if (compilation.AssemblyName != TargetAssemblyName)
            return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using AnimeFeedManager.Shared.Results;");
        sb.AppendLine("using AnimeFeedManager.Shared.Results.Errors;");
        sb.AppendLine();
        sb.AppendLine("namespace AnimeFeedManager.Shared.Results.Static;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated extension methods for Validation&lt;T&gt; chaining with flat tuple accumulation.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class ValidationAndExtensions");
        sb.AppendLine("{");

        // Generate overloads for tuple sizes 2 through MaxTupleSize
        for (int size = 2; size <= MaxTupleSize; size++)
        {
            EmitAndExtension(sb, size);
        }

        sb.AppendLine("}");

        context.AddSource("ValidationAndExtensions.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void EmitAndExtension(StringBuilder sb, int currentSize)
    {
        // For size 2: extension<T>(Validation<T> validation) with And<T2>
        // For size 3: extension<TA, TB>(Validation<(TA, TB)> validation) with And<TC>
        // etc.

        if (currentSize == 2)
        {
            EmitBaseAndExtension(sb);
        }
        else
        {
            EmitTupleAndExtension(sb, currentSize);
        }
    }

    private static void EmitBaseAndExtension(StringBuilder sb)
    {
        sb.AppendLine("    extension<T>(Validation<T> validation)");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Combines two validations, accumulating errors if both fail.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public Validation<(T, T2)> And<T2>(Validation<T2> other) =>");
        sb.AppendLine("            (validation.IsSuccess, other.IsSuccess) switch");
        sb.AppendLine("            {");
        sb.AppendLine("                (true, true) => Validation<(T, T2)>.Valid((validation.ValidValue, other.ValidValue)),");
        sb.AppendLine("                (false, false) => Validation<(T, T2)>.Invalid(validation.ErrorValue.AppendErrors(other.ErrorValue)),");
        sb.AppendLine("                (false, _) => Validation<(T, T2)>.Invalid(validation.ErrorValue),");
        sb.AppendLine("                (_, false) => Validation<(T, T2)>.Invalid(other.ErrorValue)");
        sb.AppendLine("            };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitTupleAndExtension(StringBuilder sb, int tupleSize)
    {
        // tupleSize is the size AFTER adding the new element
        // So for tupleSize=3, we have (TA, TB) + TC => (TA, TB, TC)
        int inputTupleSize = tupleSize - 1;

        // Generate type parameters: TA, TB, TC, ...
        var typeParams = GenerateTypeParams(inputTupleSize);
        var newTypeParam = GetTypeParamName(tupleSize - 1); // 0-indexed, so for size 3, index 2 = TC
        var resultTypeParams = GenerateTypeParams(tupleSize);

        // extension<TA, TB>(Validation<(TA, TB)> validation)
        sb.AppendLine($"    extension<{typeParams}>(Validation<({typeParams})> validation)");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Combines a {inputTupleSize}-tuple validation with another validation, accumulating errors if both fail.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public Validation<({resultTypeParams})> And<{newTypeParam}>(Validation<{newTypeParam}> other) =>");
        sb.AppendLine("            (validation.IsSuccess, other.IsSuccess) switch");
        sb.AppendLine("            {");

        // (true, true) case - build result tuple
        var validTupleItems = BuildTupleItems(inputTupleSize, "validation.ValidValue");
        sb.AppendLine($"                (true, true) => Validation<({resultTypeParams})>.Valid(({validTupleItems}, other.ValidValue)),");

        // (false, false) case - accumulate errors
        sb.AppendLine($"                (false, false) => Validation<({resultTypeParams})>.Invalid(validation.ErrorValue.AppendErrors(other.ErrorValue)),");

        // (false, _) case
        sb.AppendLine($"                (false, _) => Validation<({resultTypeParams})>.Invalid(validation.ErrorValue),");

        // (_, false) case
        sb.AppendLine($"                (_, false) => Validation<({resultTypeParams})>.Invalid(other.ErrorValue)");

        sb.AppendLine("            };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GenerateTypeParams(int count)
    {
        var parts = new string[count];
        for (int i = 0; i < count; i++)
        {
            parts[i] = GetTypeParamName(i);
        }
        return string.Join(", ", parts);
    }

    private static string GetTypeParamName(int index)
    {
        // 0 -> TA, 1 -> TB, 2 -> TC, etc.
        return "T" + (char)('A' + index);
    }

    private static string BuildTupleItems(int count, string prefix)
    {
        var parts = new string[count];
        for (int i = 0; i < count; i++)
        {
            parts[i] = $"{prefix}.Item{i + 1}";
        }
        return string.Join(", ", parts);
    }
}

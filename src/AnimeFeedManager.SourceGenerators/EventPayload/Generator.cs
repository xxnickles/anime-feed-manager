using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AnimeFeedManager.SourceGenerators.EventPayload;

[Generator]
public class EventPayloadSerializerGenerator : IIncrementalGenerator
{
    private const string AttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace AnimeFeedManager.SourceGenerators.EventPayload;

        /// <summary>
        /// Marks a JsonSerializerContext as a serializer context for an event payload type.
        /// The context will be registered in the auto-generated EventPayloadContextMap.
        /// </summary>
        [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
        [Microsoft.CodeAnalysis.Embedded]
        internal sealed class EventPayloadSerializerContextAttribute : System.Attribute
        {
            /// <summary>
            /// Initializes a new instance of the EventPayloadSerializerContextAttribute.
            /// </summary>
            /// <param name="payloadType">The event payload type this context serializes</param>
            public EventPayloadSerializerContextAttribute(System.Type payloadType)
            {
                PayloadType = payloadType;
            }

            /// <summary>
            /// Gets the payload type.
            /// </summary>
            public System.Type PayloadType { get; }
        }
        """;

    private static readonly DiagnosticDescriptor InvalidContextUsage = new(
        id: "EPG001",
        title: "Invalid attribute usage",
        messageFormat: "EventPayloadSerializerContextAttribute can only be applied to classes that derive from JsonSerializerContext",
        category: "EventPayloadGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private static readonly DiagnosticDescriptor InvalidPayloadType = new(
        id: "EPG002",
        title: "Invalid payload type",
        messageFormat: "EventPayloadSerializerContextAttribute payload type '{0}' must derive from SystemNotificationPayload",
        category: "EventPayloadGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the embedded attribute definition
        context.RegisterPostInitializationOutput(static postInitContext =>
        {
            postInitContext.AddEmbeddedAttributeDefinition();
            postInitContext.AddSource("EventPayloadSerializerContextAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Use ForAttributeWithMetadataName for 99x performance improvement
        var payloadContexts = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "AnimeFeedManager.SourceGenerators.EventPayload.EventPayloadSerializerContextAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetPayloadContextInfos(ctx))
            .SelectMany(static (items, _) => items)
            .Where(static m => m.HasValue)
            .Select(static (m, _) => m!.Value);

        // Combine with the compilation for diagnostics
        var compilationAndContexts = context.CompilationProvider.Combine(payloadContexts.Collect());

        // Generate the source code
        context.RegisterSourceOutput(compilationAndContexts,
            static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static ImmutableArray<(string ContextTypeName, string ContextNamespace, string PayloadTypeName, string PayloadTypeFullName,
        Location Location, bool InheritsFromJsonSerializerContext, bool PayloadInheritsFromSystemNotificationPayload)?>
        GetPayloadContextInfos(GeneratorAttributeSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;
        var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

        // Check if inherits from JsonSerializerContext (once per class)
        var jsonSerializerContextSymbol = context.SemanticModel.Compilation
            .GetTypeByMetadataName("System.Text.Json.Serialization.JsonSerializerContext");

        var inheritsFromJsonSerializerContext = jsonSerializerContextSymbol != null &&
                                                 InheritsFrom(classSymbol, jsonSerializerContextSymbol);

        var systemNotificationPayloadSymbol = context.SemanticModel.Compilation
            .GetTypeByMetadataName("AnimeFeedManager.Features.SystemEvents.SystemNotificationPayload");

        var results = ImmutableArray.CreateBuilder<(string, string, string, string, Location, bool, bool)?>();

        // Iterate all [EventPayloadSerializerContext] attributes on this class
        foreach (var attribute in context.Attributes)
        {
            if (attribute.ConstructorArguments.Length > 0 &&
                attribute.ConstructorArguments[0].Value is INamedTypeSymbol payloadType)
            {
                var payloadInheritsFromSystemNotificationPayload = systemNotificationPayloadSymbol == null ||
                                                                    InheritsFromOrEquals(payloadType, systemNotificationPayloadSymbol);

                results.Add((
                    classSymbol.Name,
                    classSymbol.ContainingNamespace.ToDisplayString(),
                    payloadType.Name,
                    payloadType.ToDisplayString(),
                    classDeclaration.GetLocation(),
                    inheritsFromJsonSerializerContext,
                    payloadInheritsFromSystemNotificationPayload
                ));
            }
        }

        return results.ToImmutable();
    }

    private static bool InheritsFrom(INamedTypeSymbol classSymbol, INamedTypeSymbol baseType)
    {
        var currentSymbol = classSymbol.BaseType;

        while (currentSymbol != null)
        {
            if (SymbolEqualityComparer.Default.Equals(currentSymbol, baseType))
            {
                return true;
            }

            currentSymbol = currentSymbol.BaseType;
        }

        return false;
    }

    private static bool InheritsFromOrEquals(INamedTypeSymbol type, INamedTypeSymbol baseType)
    {
        if (SymbolEqualityComparer.Default.Equals(type, baseType))
            return true;

        var current = type.BaseType;
        while (current is not null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
            current = current.BaseType;
        }

        return false;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<(string ContextTypeName, string ContextNamespace, string PayloadTypeName, string PayloadTypeFullName,
            Location Location, bool InheritsFromJsonSerializerContext, bool PayloadInheritsFromSystemNotificationPayload)> contexts,
        SourceProductionContext context)
    {
        if (contexts.IsDefaultOrEmpty)
            return;

        var validContexts = new List<(string ContextTypeName, string ContextNamespace, string PayloadTypeName, string PayloadTypeFullName)>();

        foreach (var ctx in contexts)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            if (!ctx.InheritsFromJsonSerializerContext)
            {
                context.ReportDiagnostic(Diagnostic.Create(InvalidContextUsage, ctx.Location));
                continue;
            }

            if (!ctx.PayloadInheritsFromSystemNotificationPayload)
            {
                context.ReportDiagnostic(Diagnostic.Create(InvalidPayloadType, ctx.Location, ctx.PayloadTypeFullName));
                continue;
            }

            validContexts.Add((ctx.ContextTypeName, ctx.ContextNamespace, ctx.PayloadTypeName, ctx.PayloadTypeFullName));
        }

        if (validContexts.Count > 0)
        {
            var source = GenerateContextMapSource(validContexts);
            context.AddSource("EventPayloadContextMap.g.cs", source);
        }
    }

    private static string GenerateContextMapSource(
        List<(string ContextTypeName, string ContextNamespace, string PayloadTypeName, string PayloadTypeFullName)> payloadContexts)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Text.Json.Serialization.Metadata;");

        // Add all the namespaces needed for the context types
        var namespaces = payloadContexts.Select(pc => pc.ContextNamespace).Distinct().ToList();
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine("namespace AnimeFeedManager.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated map of event payload types to their JSON serializer contexts.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class EventPayloadContextMap");
        sb.AppendLine("{");
        sb.AppendLine("    private static readonly Dictionary<string, (JsonSerializerContext Context, Type PayloadType)> ContextMap = new()");
        sb.AppendLine("    {");

        foreach (var (contextTypeName, _, payloadTypeName, payloadTypeFullName) in payloadContexts)
        {
            sb.AppendLine($"        [\"{payloadTypeName}\"] = ({contextTypeName}.Default, typeof({payloadTypeFullName})),");
        }

        sb.AppendLine("    };");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the JSON serializer context and payload type for the specified event payload type name.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static (JsonSerializerContext Context, Type PayloadType) GetPayloadContextInfo(string payloadTypeName)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ContextMap.TryGetValue(payloadTypeName, out var contextInfo))");
        sb.AppendLine("        {");
        sb.AppendLine("            return contextInfo;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine(
            "        throw new KeyNotFoundException($\"No serializer context found for payload type: {payloadTypeName}. Make sure the type has a JsonSerializerContext class marked with EventPayloadSerializerContextAttribute.\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets just the JSON serializer context for the specified event payload type name.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static JsonSerializerContext GetJsonSerializerContext(string payloadTypeName)");
        sb.AppendLine("    {");
        sb.AppendLine("        return GetPayloadContextInfo(payloadTypeName).Context;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}

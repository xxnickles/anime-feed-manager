@using System.Text.Json
@implements IRenderableComponent<AlternativeTitlesViewModel>

@if (Model is not null)
{
    <EditForm Model="@Model"
              hx-post="tv/alternative-title"
              hx-swap="outerHTML"
              hx-indicator="@_loaderSelector"
              hx-confirm="@($"Do you want update '{Model.SeriesTitle}' alternative titles?")"
              hx-on:htmx:confirm="if (event.detail) { 
                    const orig = event.detail.issueRequest;
                    event.detail.issueRequest = function (proceed) {
                         if (proceed) { 
                            const dlg = (event.target).closest('dialog'); 
                            dlg && dlg.close(); 
                        } 
                        return orig && orig(proceed); 
                    }; 
                }"
              x-data="{
                        items: [],
                        baseline: [],
                        normalizedBaseline: [],
                        newTitle: '',
                        dirty: false,
                        _recomputeScheduled: false,
                        init() {
                          const raw = $el.dataset.items || '[]';
                          const parseSafe = (s) => { try { return JSON.parse(s) || []; } catch { return []; } };
                          const norm = (arr) => (arr || []).map(v => (v ?? '').trim().toLowerCase());

                          // Initialize once
                          this.items = parseSafe(raw);
                          this.baseline = parseSafe(raw);
                          this.normalizedBaseline = norm(this.baseline);

                          const isEqual = (aNorm, bNorm) => {
                            if (aNorm.length !== bNorm.length) return false;
                            for (let i = 0; i < aNorm.length; i++) if (aNorm[i] !== bNorm[i]) return false;
                            return true;
                          };

                          const recomputeNow = () => {
                            // Normalize items only when recomputing
                            const itemsNorm = norm(this.items);
                            const wasDirty = this.dirty;
                            this.dirty = !isEqual(itemsNorm, this.normalizedBaseline);
                            this._recomputeScheduled = false;
                            if (wasDirty !== this.dirty) {
                              // optional: could trigger side effects here
                            }
                          };

                          const scheduleRecompute = () => {
                            if (this._recomputeScheduled) return;
                            this._recomputeScheduled = true;
                            queueMicrotask(recomputeNow); // cheap microtask batching
                          };

                          this.$watch('items', scheduleRecompute);
                          // initial compute
                          recomputeNow();
                        },
                        add() {
                          const v = (this.newTitle ?? '').trim();
                          if(!v) return;
                          const key = v.toLowerCase();
                          const exists = this.items.some(t => (t ?? '').trim().toLowerCase() === key);
                          if (exists) return;
                          this.items.push(v);
                          this.newTitle = '';
                          // debounce focus slightly to let DOM update
                          setTimeout(() => this.$refs.titleInput?.focus(), 0);
                        },
                        removeAt(i) {
                          if (i < 0 || i >= this.items.length) return;
                          this.items.splice(i, 1);
                        }
                      }"
              data-items='@JsonSerializer.Serialize(Model.AlternativeTitles ?? [])'
              class="modal-box">

        <input type="hidden" name="@nameof(Model.SeriesTitle)" value="@Model.SeriesTitle"/>
        <input type="hidden" name="@nameof(Model.SeriesId)" value="@Model.SeriesId"/>
        <input type="hidden" name="@nameof(Model.Season)" value="@Model.Season"/>

        <div class="join w-full my-3">
            <div class="w-full">
                <label class="input join-item w-full">
                    <input x-ref="titleInput" x-model="newTitle" type="text" class="w-full"
                           placeholder="Alternative Title"
                           @keydown.enter.prevent="add()"/>
                </label>
            </div>
            <button type="button" class="btn btn-neutral join-item" @click="add()">Add</button>
        </div>

        <template x-if="dirty">
            <div class="alert alert-warning my-2">
                <span>You have unsaved changes.</span>
                <span id="@_loaderId" class="loading loading-spinner loading-sm ml-2 htmx-indicator" aria-label="Saving" hx-></span>
            </div>
        </template>
        
        <ul class="list bg-base-100 shadow-md ">
            <template x-if="items.length === 0">
                <li class="p-4 pb-2 text-warning tracking-wide">No alternative titles</li>
            </template>

            <template x-for="(title, idx) in items" :key="idx">
                <li class="list-row items-center">
                    <div class="text-4xl font-thin opacity-30 tabular-nums min-w-12 text-center"
                         x-text="String(idx + 1).padStart(2,'0')"></div>
                    <div class="list-col-grow">
                        <div x-text="title"></div>
                    </div>

                    <input type="hidden"
                           :name="`${'@nameof(Model.AlternativeTitles)'}[${idx}]`"
                           :value="title"/>

                    <button type="button" class="btn btn-square btn-ghost btn-error"
                            aria-label="Remove title"
                            @click="removeAt(idx)">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                             stroke-width="1.5" stroke="currentColor" class="size-6">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                  d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"/>
                        </svg>
                    </button>
                </li>
            </template>
        </ul>

        <div class="mt-4 flex gap-2 justify-end">
            <button type="button" class="btn" @click="(e) => e.target.closest('dialog')?.close()">Close</button>
            <input type="submit" class="btn btn-primary" value="Save and close" x-show="dirty"/>
        </div>
    </EditForm>
}

@code {
    [Parameter, EditorRequired] public AlternativeTitlesViewModel? Model { get; set; }
    private string _loaderId = string.Empty;
    private string _loaderSelector = string.Empty;

    protected override void OnInitialized()
    {
        _loaderId = IdHelpers.GetUniqueName("alt-titles-loader");
        _loaderSelector = $"#{_loaderId}";
    }

    public static RenderFragment AsRenderFragment(AlternativeTitlesViewModel viewModel) => builder =>
    {
        builder.OpenComponent<AlternativeTitlesEditor>(0);
        builder.AddAttribute(1, nameof(Model), viewModel);
        builder.CloseComponent();
    };
}